<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Pong Multiplayer</title>
<style>
  body{margin:0;font-family:Inter, system-ui, Arial;background:#071021;color:#e6f2f7;display:flex;align-items:center;justify-content:center;height:100vh}
  canvas{background:#02121a;border-radius:8px;box-shadow:0 12px 40px rgba(0,0,0,0.6)}
  .ui{position:fixed;top:12px;left:12px;color:#9fb7d1}
  .badge{background:#0b1726;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.03)}
</style>
</head>
<body>
  <div class="ui badge" id="status">Conectando...</div>
  <canvas id="c" width="900" height="520"></canvas>

<script src="/socket.io/socket.io.js"></script>
<script>
  const socket = io();

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const PADDLE_H = 110, PADDLE_W = 14;

  let side = null; // 'A' | 'B' | 'S'
  let roomState = null;
  let localY = H/2 - PADDLE_H/2; // used for controlling
  const status = document.getElementById('status');

  // input
  canvas.addEventListener('pointermove', e=>{
    const r = canvas.getBoundingClientRect();
    const x = (e.clientX - r.left)*(canvas.width/r.width);
    const y = (e.clientY - r.top)*(canvas.height/r.height);
    // control only if on correct half
    if(!side || side==='S') return;
    if(side==='A' && x > W/2) return;
    if(side==='B' && x < W/2) return;
    localY = Math.max(6, Math.min(H - PADDLE_H - 6, y - PADDLE_H/2));
    // send update to server (pixel y)
    socket.emit('paddle', { y: localY });
  });

  canvas.addEventListener('pointerdown', e=>{
    // serve if not running
    if(!roomState || roomState.running) return;
    socket.emit('serve');
  });

  socket.on('connect', ()=> status.innerText = 'Conectado. Aguardando atribuição...');
  socket.on('assigned', data => {
    side = data.side;
    status.innerText = side === 'A' ? 'Você é Jogador A (esquerda)' : side === 'B' ? 'Você é Jogador B (direita)' : 'Espectador';
  });

  socket.on('gameStart', d => {
    roomState = roomState || {};
    roomState.running = true;
    status.innerText = 'Jogo iniciado! Servindo: ' + d.servingSide;
  });

  socket.on('playerLeft', ()=> {
    status.innerText = 'Alguém saiu — aguardando jogador';
  });

  socket.on('state', s => {
    roomState = s;
    render(s);
  });

  // request initial state in case we connected late
  socket.emit('requestState');

  function render(s){
    // clear
    ctx.fillStyle = '#02121a'; ctx.fillRect(0,0,W,H);

    // center line
    ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.setLineDash([8,8]); ctx.beginPath(); ctx.moveTo(W/2,8); ctx.lineTo(W/2,H-8); ctx.stroke(); ctx.setLineDash([]);

    // draw paddles from state or local control
    // default positions
    let leftY = H/2 - PADDLE_H/2;
    let rightY = H/2 - PADDLE_H/2;
    (s.players||[]).forEach(p=> {
      if(p.side==='A') leftY = p.y;
      if(p.side==='B') rightY = p.y;
    });

    // if I'm a player, override my side with localY (so my paddle is responsive)
    if(side==='A') leftY = localY;
    if(side==='B') rightY = localY;

    // draw paddles
    ctx.fillStyle = '#e6f2f7'; ctx.fillRect(30, leftY, PADDLE_W, PADDLE_H);
    ctx.fillRect(W - 30 - PADDLE_W, rightY, PADDLE_W, PADDLE_H);

    // ball
    if(s.ball){
      ctx.beginPath(); ctx.fillStyle = '#4dd0e1'; ctx.arc(s.ball.x, s.ball.y, s.ball.r, 0, Math.PI*2); ctx.fill();
    }

    // scores
    ctx.fillStyle = '#9fb7d1'; ctx.font='26px sans-serif'; ctx.textAlign='left'; ctx.fillText('A: ' + s.scoreA, 24, 36);
    ctx.textAlign='right'; ctx.fillText('B: ' + s.scoreB, W - 24, 36);
  }

  // on disconnect
  socket.on('disconnect', ()=> status.innerText = 'Desconectado. Recarregue para reconectar.');
</script>
</body>
</html>
